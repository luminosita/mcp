version: '3'

# AI Agent MCP Server - Development Tasks
# Consolidated CLI interface for all development operations
# See: /prompts/CLAUDE/CLAUDE-tooling.md for detailed documentation

vars:
  SRC_DIR: src
  TESTS_DIR: tests
  COVERAGE_MIN: 80
  PYTHON_VERSION: "3.11"
  PROJECT_NAME: mcp_server
  IMAGE_NAME: ai-agent-mcp-server
  TAG: latest
  CONTAINER_NAME: mcp-server
  DB_CONTAINER_NAME: mcp-postgres
  DB_USER: mcp_user
  DB_PASSWORD: dev_password_change_in_production
  DB_NAME: mcp_dev

tasks:
  # ====================
  # Code Quality Tasks
  # ====================

  lint:
    desc: Run Ruff linter (check only, no fixes)
    cmds:
      - uv run ruff check .

  lint:fix:
    desc: Run Ruff linter with auto-fix
    cmds:
      - uv run ruff check --fix .

  lint:watch:
    desc: Run Ruff linter in watch mode
    cmds:
      - uv run ruff check --watch .

  format:
    desc: Format code with Ruff formatter
    cmds:
      - uv run ruff format .

  format:check:
    desc: Check formatting without changes
    cmds:
      - uv run ruff format --check .

  lint:all:
    desc: Run linting and formatting together
    cmds:
      - uv run ruff check --fix .
      - uv run ruff format .

  # ====================
  # Security & Vulnerability Scanning
  # ====================

  security:bandit:
    desc: Run bandit security scanner for Python code
    cmds:
      - uv run bandit -r {{.SRC_DIR}}/ -f json -o bandit-report.json || true
      - uv run bandit -r {{.SRC_DIR}}/

  security:safety:
    desc: Check dependencies for known vulnerabilities
    cmds:
      - uv run safety check --json || true

  security:all:
    desc: Run all security scans (bandit + safety)
    cmds:
      - task: security:bandit
      - task: security:safety

  # ====================
  # Type Checking Tasks
  # ====================

  type-check:
    desc: Run MyPy type checker (strict mode)
    cmds:
      - uv run mypy {{.SRC_DIR}}/ --strict

  type-check:report:
    desc: Generate MyPy HTML type coverage report
    cmds:
      - uv run mypy {{.SRC_DIR}}/ --html-report ./mypy-report
      - echo "Report generated at mypy-report/index.html"

  type-check:install:
    desc: Install missing type stubs
    cmds:
      - uv run mypy --install-types

  # ====================
  # Testing Tasks
  # ====================

  test:
    desc: Run all tests with coverage
    cmds:
      - uv run pytest --cov={{.SRC_DIR}} --cov-report=html --cov-report=term

  test:unit:
    desc: Run unit tests only
    cmds:
      - uv run pytest {{.TESTS_DIR}}/unit -v

  test:integration:
    desc: Run integration tests only
    cmds:
      - uv run pytest {{.TESTS_DIR}}/integration -v

  test:e2e:
    desc: Run end-to-end tests only
    cmds:
      - uv run pytest {{.TESTS_DIR}}/e2e -v

  test:watch:
    desc: Run tests in watch mode
    cmds:
      - uv run pytest-watch

  test:verbose:
    desc: Run tests with verbose output
    cmds:
      - uv run pytest -v

  test:failed:
    desc: Run only last failed tests
    cmds:
      - uv run pytest --lf

  test:coverage:
    desc: Run tests and enforce {{.COVERAGE_MIN}}% coverage
    cmds:
      - uv run pytest --cov={{.SRC_DIR}} --cov-report=html --cov-report=xml --cov-fail-under={{.COVERAGE_MIN}}

  test:parallel:
    desc: Run tests in parallel
    cmds:
      - uv run pytest -n auto

  test:mark:
    desc: Run tests by marker (usage - task test:mark -- MARKER=integration)
    cmds:
      - uv run pytest -m "{{.MARKER}}"

  # ====================
  # Quality Check (All)
  # ====================

  check:
    desc: Run all quality checks (lint, format, type-check, test)
    cmds:
      - task: format:check
      - task: lint
      - task: security:all
      - task: type-check
      - task: test:coverage

  check:ci:
    desc: Run CI/CD pipeline checks (frozen deps)
    cmds:
      - task: deps:install:ci
      - task: lint
      - task: format:check
      - task: type-check
      - task: test:coverage
      - task: security:all

  # ====================
  # Dependency Management
  # ====================

  deps:install:
    desc: Install project dependencies
    cmds:
      - uv sync

  deps:install:all:
    desc: Install all dependencies including extras
    cmds:
      - uv sync --all-extras

  deps:install:ci:
    desc: Install dependencies for CI (frozen lockfile with all extras)
    cmds:
      - uv sync --all-extras --frozen

  deps:add:
    desc: Add a new dependency (usage - task deps:add -- PKG=requests)
    cmds:
      - uv add {{.PKG}}

  deps:add:dev:
    desc: Add a dev dependency (usage - task deps:add:dev -- PKG=pytest)
    cmds:
      - uv add --dev {{.PKG}}

  deps:remove:
    desc: Remove a dependency (usage - task deps:remove -- PKG=requests)
    cmds:
      - uv remove {{.PKG}}

  deps:lock:
    desc: Update lockfile without installing
    cmds:
      - uv lock

  deps:update:
    desc: Update dependencies (via Renovate - manual fallback)
    cmds:
      - uv lock --upgrade
      - uv sync

  deps:export:
    desc: Export dependencies to requirements.txt
    cmds:
      - uv export --format requirements-txt --output-file requirements.txt

  # ====================
  # Pre-commit Hooks
  # ====================

  hooks:install:
    desc: Install pre-commit hooks for Python (using pre-commit framework)
    cmds:
      - pre-commit install

  hooks:run:
    desc: Run pre-commit hooks manually on all files
    cmds:
      - pre-commit run --all-files

  hooks:update:
    desc: Update pre-commit hooks to latest versions
    cmds:
      - pre-commit autoupdate
      - echo "‚úÖ Pre-commit hooks updated"

  hooks:uninstall:
    desc: Uninstall pre-commit hooks
    cmds:
      - pre-commit uninstall
      - echo "‚úÖ Pre-commit hooks uninstalled"

  # ====================
  # Build & Run Tasks
  # ====================

  build:
    desc: Build Python package
    cmds:
      - uv build

  run:
    desc: Run application (usage - task run -- SCRIPT=main.py)
    cmds:
      - uv run python {{.SCRIPT | default "main.py"}}

  dev:
    desc: Start development server with hot-reload in Devbox
    cmds:
      - uv run uvicorn {{.PROJECT_NAME}}.main:app --reload --reload-dir {{.SRC_DIR}}/ --reload-delay 0.25 --host 0.0.0.0 --port 8000 --log-level info

  shell:
    desc: Start Python REPL with project loaded
    cmds:
      - uv run python

  # ====================
  # Container Tasks (Podman/Docker)
  # ====================

  container:build:
    desc: Build production container image using multi-stage Containerfile
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
      TAG: '{{.TAG | default "latest"}}'
    cmds:
      - '{{.RUNTIME}} build -t {{.IMAGE_NAME}}:{{.TAG}} -f Containerfile .'
      - echo "‚úÖ Built {{.IMAGE_NAME}}:{{.TAG}} using {{.RUNTIME}}"

  container:run:
    desc: Run production container locally with port mapping
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
      TAG: '{{.TAG | default "latest"}}'
      ENV_FILE: '{{.ENV_FILE | default ".env"}}'
    cmds:
      - |
        if [ -f "{{.ENV_FILE}}" ]; then
          {{.RUNTIME}} run -d --name {{.CONTAINER_NAME}} -p 8000:8000 --env-file {{.ENV_FILE}} {{.IMAGE_NAME}}:{{.TAG}}
        else
          {{.RUNTIME}} run -d --name {{.CONTAINER_NAME}} -p 8000:8000 {{.IMAGE_NAME}}:{{.TAG}}
        fi
      - echo "‚úÖ Container {{.CONTAINER_NAME}} started using {{.RUNTIME}}"
      - echo "Application available at http://localhost:8000"

  container:stop:
    desc: Stop running container
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - '{{.RUNTIME}} stop {{.CONTAINER_NAME}} || true'
      - '{{.RUNTIME}} rm {{.CONTAINER_NAME}} || true'
      - echo "‚úÖ Container {{.CONTAINER_NAME}} stopped"

  container:logs:
    desc: View container logs
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - '{{.RUNTIME}} logs -f {{.CONTAINER_NAME}}'

  container:shell:
    desc: Open shell in running container for debugging
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - '{{.RUNTIME}} exec -it {{.CONTAINER_NAME}} /bin/sh'

  container:clean:
    desc: Remove all containers and images
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - '{{.RUNTIME}} stop {{.CONTAINER_NAME}} || true'
      - '{{.RUNTIME}} rm {{.CONTAINER_NAME}} || true'
      - '{{.RUNTIME}} rmi {{.IMAGE_NAME}}:latest || true'
      - echo "‚úÖ Cleaned up containers and images"

  container:scan:
    desc: Scan container image for security vulnerabilities using Trivy
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
      TAG: '{{.TAG | default "latest"}}'
      SEVERITY: '{{.SEVERITY | default "CRITICAL,HIGH,MEDIUM,LOW"}}'
      IMAGE_REF: 'localhost/{{.IMAGE_NAME}}:{{.TAG}}'
    cmds:
      - |
        # Check if Trivy is installed
        if ! command -v trivy >/dev/null 2>&1; then
          echo "‚ùå Trivy not installed. Install with:"
          echo "   macOS: brew install aquasecurity/trivy/trivy"
          echo "   Linux: https://aquasecurity.github.io/trivy/latest/getting-started/installation/"
          exit 1
        fi

        # Set DOCKER_HOST for Podman if available
        if command -v podman >/dev/null 2>&1; then
          PODMAN_SOCKET=$(podman machine inspect --format '{{`{{.ConnectionInfo.PodmanSocket.Path}}`}}' 2>/dev/null)
          if [ -n "$PODMAN_SOCKET" ]; then
            export DOCKER_HOST="unix://$PODMAN_SOCKET"
          fi
        fi

        echo "üîç Scanning {{.IMAGE_REF}} for vulnerabilities..."
        trivy image --severity {{.SEVERITY}} {{.IMAGE_REF}}

  container:scan:critical:
    desc: Scan for critical and high severity vulnerabilities only
    vars:
      TAG: '{{.TAG | default "latest"}}'
    cmds:
      - task: container:scan
        vars:
          TAG: '{{.TAG}}'
          SEVERITY: CRITICAL,HIGH

  container:scan:sarif:
    desc: Generate SARIF security report for GitHub Security integration
    vars:
      TAG: '{{.TAG | default "latest"}}'
      OUTPUT_FILE: '{{.OUTPUT_FILE | default "trivy-results.sarif"}}'
      IMAGE_REF: 'localhost/{{.IMAGE_NAME}}:{{.TAG}}'
    cmds:
      - |
        # Check if Trivy is installed
        if ! command -v trivy >/dev/null 2>&1; then
          echo "‚ùå Trivy not installed. Install with:"
          echo "   macOS: brew install aquasecurity/trivy/trivy"
          echo "   Linux: https://aquasecurity.github.io/trivy/latest/getting-started/installation/"
          exit 1
        fi

        # Set DOCKER_HOST for Podman if available
        if command -v podman >/dev/null 2>&1; then
          PODMAN_SOCKET=$(podman machine inspect --format '{{`{{.ConnectionInfo.PodmanSocket.Path}}`}}' 2>/dev/null)
          if [ -n "$PODMAN_SOCKET" ]; then
            export DOCKER_HOST="unix://$PODMAN_SOCKET"
          fi
        fi

        echo "üîç Generating SARIF report for {{.IMAGE_REF}}..."
        trivy image --format sarif --output {{.OUTPUT_FILE}} {{.IMAGE_REF}}
        echo "‚úÖ SARIF report saved to {{.OUTPUT_FILE}}"
        echo "Upload to GitHub: gh api repos/:owner/:repo/code-scanning/sarifs -F sarif=@{{.OUTPUT_FILE}}"

  container:scan:json:
    desc: Generate JSON security report for programmatic analysis
    vars:
      TAG: '{{.TAG | default "latest"}}'
      OUTPUT_FILE: '{{.OUTPUT_FILE | default "trivy-results.json"}}'
      IMAGE_REF: 'localhost/{{.IMAGE_NAME}}:{{.TAG}}'
    cmds:
      - |
        # Check if Trivy is installed
        if ! command -v trivy >/dev/null 2>&1; then
          echo "‚ùå Trivy not installed. Install with:"
          echo "   macOS: brew install aquasecurity/trivy/trivy"
          echo "   Linux: https://aquasecurity.github.io/trivy/latest/getting-started/installation/"
          exit 1
        fi

        # Set DOCKER_HOST for Podman if available
        if command -v podman >/dev/null 2>&1; then
          PODMAN_SOCKET=$(podman machine inspect --format '{{`{{.ConnectionInfo.PodmanSocket.Path}}`}}' 2>/dev/null)
          if [ -n "$PODMAN_SOCKET" ]; then
            export DOCKER_HOST="unix://$PODMAN_SOCKET"
          fi
        fi

        echo "üîç Generating JSON report for {{.IMAGE_REF}}..."
        trivy image --format json --output {{.OUTPUT_FILE}} {{.IMAGE_REF}}
        echo "‚úÖ JSON report saved to {{.OUTPUT_FILE}}"

  # ====================
  # Database Tasks (Podman/Docker)
  # ====================

  db:start:
    desc: Start PostgreSQL + pgvector container for local development
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - |
        {{.RUNTIME}} run -d \
          --name {{.DB_CONTAINER_NAME}} \
          -e POSTGRES_USER={{.DB_USER}} \
          -e POSTGRES_PASSWORD={{.DB_PASSWORD}} \
          -e POSTGRES_DB={{.DB_NAME}} \
          -p 5432:5432 \
          -v pgdata:/var/lib/postgresql/data \
          -v $(pwd)/scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro \
          ankane/pgvector:latest
      - echo "‚úÖ PostgreSQL + pgvector container started"
      - echo "Database accessible at localhost:5432"
      - echo "Waiting for database to be ready..."
      - sleep 5

  db:stop:
    desc: Stop database container gracefully
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - '{{.RUNTIME}} stop {{.DB_CONTAINER_NAME}} || true'
      - '{{.RUNTIME}} rm {{.DB_CONTAINER_NAME}} || true'
      - echo "‚úÖ Database container stopped"

  db:reset:
    desc: Reset database to clean state (WARNING - destroys data)
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - echo "‚ö†Ô∏è  WARNING - This will destroy all database data!"
      - echo "Press Ctrl+C to cancel, or wait 5 seconds to continue..."
      - sleep 5
      - task: db:stop
      - '{{.RUNTIME}} volume rm pgdata || true'
      - echo "‚úÖ Database volume removed"
      - task: db:start

  db:logs:
    desc: View database container logs
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - '{{.RUNTIME}} logs -f {{.DB_CONTAINER_NAME}}'

  db:shell:
    desc: Connect to PostgreSQL shell
    vars:
      RUNTIME:
        sh: command -v podman >/dev/null 2>&1 && echo "podman" || echo "docker"
    cmds:
      - '{{.RUNTIME}} exec -it {{.DB_CONTAINER_NAME}} psql -U {{.DB_USER}} -d {{.DB_NAME}}'

  db:restart:
    desc: Restart database container
    cmds:
      - task: db:stop
      - task: db:start

  # ====================
  # Database Migration Tasks (Alembic)
  # ====================

  db:migrate:create:
    desc: Create new database migration
    cmds:
      - uv run alembic revision --autogenerate -m "{{.CLI_ARGS}}"
      - echo "‚úÖ Migration created - review generated file in migrations/versions/"

  db:migrate:up:
    desc: "Apply pending database migrations (alias: db:migrate)"
    cmds:
      - uv run alembic upgrade head
      - echo "‚úÖ Migrations applied successfully"

  db:migrate:
    desc: "Apply pending database migrations (alias for db:migrate:up)"
    cmds:
      - task: db:migrate:up

  db:migrate:down:
    desc: "Rollback last database migration (alias: db:migrate:rollback)"
    cmds:
      - uv run alembic downgrade -1
      - echo "‚úÖ Last migration rolled back"

  db:migrate:rollback:
    desc: "Rollback last database migration (alias for db:migrate:down)"
    cmds:
      - task: db:migrate:down

  db:migrate:status:
    desc: Show migration status (applied and pending)
    cmds:
      - echo "Current migration version:"
      - uv run alembic current
      - echo ""
      - echo "Migration history:"
      - uv run alembic history

  # ====================
  # SonarQube Tasks (Code Quality Analysis)
  # ====================

  sonar:start:
    desc: Start SonarQube server with PostgreSQL backend
    vars:
      RUNTIME:
        sh: command -v podman-compose >/dev/null 2>&1 && echo "podman-compose" || echo "docker-compose"
    cmds:
      - '{{.RUNTIME}} up -d'
      - echo "‚úÖ SonarQube starting (may take 1-2 minutes)..."
      - echo "Access SonarQube at http://localhost:9000"
      - echo "Default credentials - admin/admin (change on first login)"
      - echo "Waiting for SonarQube to be ready..."
      - |
        for i in {1..60}; do
          if curl -s http://localhost:9000/api/system/status | grep -q '"status":"UP"'; then
            echo "‚úÖ SonarQube is ready!"
            exit 0
          fi
          echo -n "."
          sleep 2
        done
        echo ""
        echo "‚ö†Ô∏è  SonarQube may still be starting. Check logs with: task sonar:logs"

  sonar:stop:
    desc: Stop SonarQube server
    vars:
      RUNTIME:
        sh: command -v podman-compose >/dev/null 2>&1 && echo "podman-compose" || echo "docker-compose"
    cmds:
      - '{{.RUNTIME}} down'
      - echo "‚úÖ SonarQube stopped"

  sonar:restart:
    desc: Restart SonarQube server
    cmds:
      - task: sonar:stop
      - task: sonar:start

  sonar:logs:
    desc: View SonarQube server logs
    vars:
      RUNTIME:
        sh: command -v podman-compose >/dev/null 2>&1 && echo "podman-compose" || echo "docker-compose"
    cmds:
      - '{{.RUNTIME}} logs -f sonarqube'

  sonar:clean:
    desc: Stop SonarQube and remove all data (WARNING - destroys analysis history)
    vars:
      RUNTIME:
        sh: command -v podman-compose >/dev/null 2>&1 && echo "podman-compose" || echo "docker-compose"
    cmds:
      - echo "‚ö†Ô∏è  WARNING - This will destroy all SonarQube data and analysis history!"
      - echo "Press Ctrl+C to cancel, or wait 5 seconds to continue..."
      - sleep 5
      - '{{.RUNTIME}} down -v'
      - echo "‚úÖ SonarQube data removed"

  sonar:scan:
    desc: Run SonarQube code analysis (requires running SonarQube server)
    cmds:
      - |
        if ! command -v sonar-scanner >/dev/null 2>&1; then
          echo "‚ùå sonar-scanner not installed. Install with:"
          echo "   macOS: brew install sonar-scanner"
          echo "   Linux: https://docs.sonarqube.org/latest/analyzing-source-code/scanners/sonarscanner/"
          exit 1
        fi
      - echo "üìä Generating test coverage report..."
      - uv run pytest --cov={{.SRC_DIR}} --cov-report=xml --cov-report=term
      - echo "üîç Running SonarQube analysis..."
      - sonar-scanner -Dsonar.host.url=http://localhost:9000 -Dsonar.token=sqb_f0bf20d90a94eac6393506d9da7b876933e9ab29
      - echo "‚úÖ Analysis complete - view results at http://localhost:9000"

  sonar:scan:ci:
    desc: Run SonarQube scan for CI/CD with token authentication
    cmds:
      - |
        if [ -z "$SONAR_TOKEN" ]; then
          echo "‚ùå SONAR_TOKEN environment variable not set"
          echo "Generate token at http://localhost:9000/account/security"
          exit 1
        fi
      - echo "üìä Generating test coverage report..."
      - uv run pytest --cov={{.SRC_DIR}} --cov-report=xml --cov-report=term
      - echo "üîç Running SonarQube analysis with token..."
      - sonar-scanner -Dsonar.host.url=http://localhost:9000 -Dsonar.token=$SONAR_TOKEN
      - echo "‚úÖ Analysis complete"

  # ====================
  # Documentation Tasks
  # ====================

  docs:build:
    desc: Build documentation
    cmds:
      - echo "Documentation build not yet configured"
      - echo "Add MkDocs or Sphinx configuration"

  docs:serve:
    desc: Serve documentation locally
    cmds:
      - echo "Documentation serve not yet configured"

  # ====================
  # Performance Testing Tasks (US-033)
  # ====================

  perf:test:
    desc: Run full load test (100 users, 5 minutes) - validates <100ms p95 target
    cmds:
      - echo "üî• Starting load test (100 users, 5 minutes)..."
      - echo "Target - less than 100ms p95 latency for resource loading"
      - echo "Results will be saved to perf-results.csv"
      - uv run locust -f locustfile.py --headless --users 100 --spawn-rate 10 --run-time 5m --csv=perf-results --html=perf-report.html --host http://localhost:8000
      - echo "‚úÖ Load test complete - see perf-report.html for results"

  perf:test:quick:
    desc: Run quick load test (30 users, 1 minute) - for CI/CD
    cmds:
      - echo "üî• Starting quick load test (30 users, 1 minute)..."
      - uv run locust -f locustfile.py --headless --users 30 --spawn-rate 5 --run-time 1m --csv=perf-quick --host http://localhost:8000
      - echo "‚úÖ Quick load test complete"

  perf:profile:
    desc: Profile running server with py-spy (60 seconds)
    cmds:
      - |
        echo "üîç Profiling server with py-spy (60 seconds)..."
        echo "Ensure server is running: task dev"
        echo "Finding uvicorn process..."
        PID=$(pgrep -f "uvicorn.*mcp_server.main:app" | head -1)
        if [ -z "$PID" ]; then
          echo "‚ùå Server not running. Start with: task dev"
          exit 1
        fi
        echo "Found server PID: $PID"
        echo "Recording profile for 60 seconds..."
        uv run py-spy record -o profile.svg --pid $PID --duration 60 --rate 100
        echo "‚úÖ Profile saved to profile.svg"
        echo "Open profile.svg in browser to view flame graph"

  perf:profile:interactive:
    desc: Interactive profiling with py-spy top command
    cmds:
      - |
        echo "üîç Starting interactive profiling..."
        PID=$(pgrep -f "uvicorn.*mcp_server.main:app" | head -1)
        if [ -z "$PID" ]; then
          echo "‚ùå Server not running. Start with: task dev"
          exit 1
        fi
        echo "Found server PID: $PID"
        echo "Press Ctrl+C to stop profiling"
        uv run py-spy top --pid $PID

  perf:benchmark:
    desc: Run performance benchmarks and save to docs/performance-runbook.md
    cmds:
      - echo "üìä Running performance benchmarks..."
      - 'echo "Step 1/3: Quick warmup test (10 users, 30 seconds)"'
      - uv run locust -f locustfile.py --headless --users 10 --spawn-rate 5 --run-time 30s --host http://localhost:8000 >/dev/null 2>&1
      - 'echo "Step 2/3: Full load test (100 users, 5 minutes)"'
      - uv run locust -f locustfile.py --headless --users 100 --spawn-rate 10 --run-time 5m --csv=benchmark-results --html=benchmark-report.html --host http://localhost:8000
      - 'echo "Step 3/3: Generating performance runbook..."'
      - echo "‚úÖ Benchmarks complete - results in benchmark-report.html"
      - echo "üìù Document results in docs/performance-runbook.md"

  perf:clean:
    desc: Clean performance test artifacts
    cmds:
      - rm -f perf-results*.csv perf-quick*.csv benchmark-results*.csv
      - rm -f perf-report.html benchmark-report.html
      - rm -f profile.svg
      - echo "‚úÖ Performance artifacts cleaned"

  # ====================
  # Utility Tasks
  # ====================

  clean:
    desc: Clean build artifacts and caches
    cmds:
      - rm -rf build/ dist/ *.egg-info
      - rm -rf .pytest_cache .mypy_cache .ruff_cache
      - rm -rf htmlcov/ .coverage coverage.xml
      - rm -rf mypy-report/
      - find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true

  clean:all:
    desc: Clean everything including virtual environments
    cmds:
      - task: clean
      - rm -rf .venv venv

  setup:
    desc: Initial project setup (install deps and hooks)
    cmds:
      - nu <(curl -fsSL file:///Users/gianni/dev/sandbox/setup-env/dist/setup.nu)
      - uv sync --all-extras
      - task: hooks:install
      - echo "‚úÖ Project setup complete"

  info:
    desc: Show project environment information
    cmds:
      - echo "Project - {{.PROJECT_NAME}}"
      - echo "Python Version - {{.PYTHON_VERSION}}"
      - echo "Coverage Minimum - {{.COVERAGE_MIN}}%"
      - echo ""
      - uv --version
      - python --version
      - ruff --version
      - mypy --version
      - pytest --version

  help:
    desc: Show available tasks
    cmds:
      - task --list
